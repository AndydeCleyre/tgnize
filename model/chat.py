#!/usr/bin/python3

from __future__ import annotations
from typing import List
from activity import Activity
from user import User


class Chat:

    def __init__(self, activities: List[Activity], users: List[User]):
        self.activities = activities
        self.users = users
        self._activityCount = len(self.activities)
        self._userCount = len(self.users)

    @property
    def activityCount(self) -> int:
        return self._activityCount

    @property
    def userCount(self) -> int:
        return self._userCount

    '''
        Gives us an iterator for traversing
        over an instance of Chat object
    '''

    def __iter__(self):
        return iter(self.activities)

    '''
        Returns position, at which we need to insert
        a new Activity ( for this chat ), so that
        ascendingly sorted order is kept.
        
        Position is found using binary search mechanism.
    '''

    def __getPushPosition__(self, idx: int, low: int, high: int):
        if low > high:
            return 0
        elif low == high:
            return low if self.activities[low].index > idx else (low + 1)
        else:
            mid = (low + high) // 2
            return self.__getPushPosition__(idx, low, mid) \
                if self.activities[mid].index > idx \
                else self.__getPushPosition__(idx, mid + 1, high)

    '''
        Pushes an instance of Activity subclass ( either Event or Message )
        into collection of all activities happened in chat
        in proper position, so that sorted order is kept
        ( ascending in terms of index of Activity )
    '''

    def push(self, item: Activity):
        self.activities.insert(self.__getPushPosition__(
            item.index, 0, len(self.activities) - 1), item)
        self._activityCount += 1

    '''
        Denotes whether this activity is an Event
        or not

        If not an event, then it's a Message, sent by
        some chat participant
    '''

    def isEvent(self, idx: int) -> bool:
        try:
            self.getActivity(idx).user
            return False
        except Exception:
            return True

    '''
        As all entries made into chat holder are organized in
        sorted fashion in terms of their index number,
        we can reduce search time by doing it using binary search.

        That's what is done here.
    '''

    def __getActivity__(self, idx: int, low: int, high: int) -> int:
        if low > high:
            return -1
        elif low == high:
            return low if self.activities[low].index == idx else -1
        else:
            mid = (low + high) // 2
            return self.__getActivity__(idx, low, mid) \
                if self.activities[mid].index >= idx \
                else self.__getActivity__(idx, mid + 1, high)

    '''
        Finds an activity ( may be event or message ),
        happened in group by its corresponding index value 
        ( well this index is generated by telegram desktop 
        application, while exporting chat, which is to be examined )
    '''

    def getActivity(self, idx: int) -> Activity:
        tmp = self.__getActivity__(idx, 0, len(self.activities) - 1)
        return self.activities[tmp] if tmp != -1 else None

    '''
        Helps in finding proper insertion position
        for an User object, so that self.users
        stays ascendingly sorted even after insertion at this
        position.

        This position finding is done using recursive mechanism ( binary search )
    '''

    def __pushUserPosition__(self, user: str, low: int, high: int):
        if low > high:
            return 0
        elif low == high:
            return low if self.users[low].name > user else (low + 1)
        else:
            mid = (low + high) // 2
            return self.__pushUserPosition__(user, low, mid) \
                if self.users[mid].name > user \
                else self.__pushUserPosition__(user, mid + 1, high)

    '''
        Pushes an User object into self.users,
        such that they list stays ascendingly sorted
        by user names.
    '''

    def pushUser(self, user: User):
        self.users.insert(self.__pushUserPosition__(
            user.name, 0, len(self.users) - 1), user)
        self._userCount += 1

    '''
        Finds an User object by its name,
        in recursive fashion, using binary search mechanism.
        
        Cause self.users is always kept sorted in ascending fashion
        by user names.
    '''

    def __getUser__(self, user: str, low: int, high: int):
        if low > high:
            return -1
        elif low == high:
            return low if self.users[low].name == user else -1
        else:
            mid = (low + high) // 2
            return self.__getUser__(user, low, mid) \
                if self.users[mid].name >= user \
                else self.__getUser__(user, mid + 1, high)

    '''
        Looks up an User object by user name,
        if it's present in self.records,
        we simply return that object,
        other wise we return None, denoting failure.
    '''

    def getUser(self, user: str) -> User:
        _tmp = self.__getUser__(user, 0, len(self.users) - 1)
        return self.users[_tmp] if _tmp != -1 else None

    '''
        Takes an user ( indentifying ) name & a message id, 
        denoting that message is sent by that user,
        and tries to lookup an User object with
        that username.

        Now there may be two conditions

        Either User object with that name is already exisiting,
        in that case, we simply update its messageID container list,
        while pushing this one.

        Or we need to create an User object with that name,
        along with this messageID, and push that into proper
        place while maintaining ascendingly sorted order of Users,
        into self.users : List[User]
    '''

    def updateUserRecords(self, user: str, messageID: int):
        _tmp = self.getUser(user)
        if not _tmp:
            self.pushUser(User(user, [messageID]))
        else:
            _tmp.messageIDs.append(messageID)


if __name__ == '__main__':
    print('[!]This module is expected to be used as a backend handler')
    exit(0)
